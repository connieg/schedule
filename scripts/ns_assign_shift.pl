#! /opt/csw/bin/perl
use strict;
use warnings;
use Date::Calc "Delta_DHMS";
use DBI;
use POSIX;

# ns_assign_shift.pl
# Assigns shifts to a DOG for a given day of the week and hour or range of
# hours. 

# Some configuration items

my $db = "schedule";
my $host = "db.cecs.pdx.edu";
my $user = "schedule";
my $password = "jm)n3Ffz6m";
my $dbh = DBI->connect ("DBI:mysql:database=$db:host=$host",$user,$password) or die "Can't connect to database: $DBI::errstr\n";

# Which types of CATs are eligible for desk duty?
my @dog_types = (2,1);

my $invalid_args_message = "Invalid arguments. Use one of the following:
-i (for interactive mode)
catname termname yyyy day(name or numeric) hhmm(start time) hhmm(end time) desk\n";

# Main body

# Process arguments
# Has two modes of operating, interactive (-i) or arguments provided in 
# invocation. 

if (!defined $ARGV[0]) {
	print $invalid_args_message;
# If $ARGV[0] eq -i, and is the only argument, enter interactive mode
} elsif ($ARGV[0] eq "-i" && @ARGV == 1) {
	print "Interactive mode.\n";

# If $ARGV[0] is something else, assume user is trying to provide arguments in
# invocation and start doing sanity checking on the arguments provided. 
# Formatting for this style of arguments should look like:
# ns_assign_shift.pl catname termname yyyy day hhmm hhmm desk
# First check if we got the correct number of arguments
} elsif (@ARGV == 7) {
	
	# Commented keys are populated later in the program.
	my %args = (
	dog_name	=>	$ARGV[0],
	#dog_id		=>	0,
	term_name	=>	$ARGV[1] . " " . $ARGV[2],
	#term_id	=>	0,
	#term_startdate	=>	{yyyy-mm-dd,yyyy,mm,dd}
	#term_enddate	=>	{yyyy-mm-dd,yyyy,mm,dd}
	desk_name	=>	$ARGV[6],
	#desk_id	=>	0,
	day_name	=>	$ARGV[3],
	#day_id		=>	0,
	start_time	=>	{
			actual	=>	$ARGV[4],	
			hh	=>	($ARGV[4] =~ /(\d\d)\d\d/),
			mm	=> 	($ARGV[4] =~ /\d\d(\d\d)/),}, 
	end_time	=>	{
			actual	=>	$ARGV[5],
			hh	=>	($ARGV[5] =~ /(\d\d)\d\d/),
			mm	=>	($ARGV[5] =~ /\d\d(\d\d)/),},
	);

	# Make sure catname is in the list of CATs eligible for desk duty generated by get_dogs()
	my $dogs_hash_ref = get_dogs(\@dog_types);
	$args{dog_id} = get_id_from_value($args{dog_name},$dogs_hash_ref);
	if ($args{dog_id} eq "no match") {
		print "No such dog \"$args{dog_name}\" eligible for desk duty found.\n";
		exit;
	} else {
		print "$args{dog_name} has id $args{dog_id} and is eligible for desk duty.\n";
	};
	
	# Make sure a valid term has been specified, check against output of get_terms()
	my $terms_hash_ref = get_terms();
	$args{term_id} = get_id_from_value($args{term_name},$terms_hash_ref);
	if ($args{term_id} eq "no match") {
		print "No such term \"$args{term_name}\" exists in the database.\n";
		exit;
	} else { 
		print "$args{term_name} has id $args{term_id}.\n";
	};

	# Make sure the day, start time, and end time make sense 
	# Check that the day, start time, and end time given are in a valid 
	# format and represent valid values of their type (the name of a day of
	# the week, and an hour between 0000 and 2300 for the start and end
	# times).
	# Check that the day specified was not Sunday, get the numerical value
	# for the name of the day provided.
	if ($args{day_name} =~ m/monday/i) {
		$args{day_id} = 1;
	} elsif ($args{day_name} =~ m/tuesday/i) {
		$args{day_id} = 2;
	} elsif ($args{day_name} =~ m/wednesday/i) { 
		$args{day_id} = 3;
	} elsif ($args{day_name} =~ m/thursday/i) {
		$args{day_id} = 4;
	} elsif ($args{day_name} =~ m/friday/i) {
		$args{day_id} = 5;
	} elsif ($args{day_name} =~ m/saturday/i) {
		$args{day_id} = 6;
	} else {
		print "Invalid day specified ($args{day_name}).\n";
		exit;
	};
	print "Scheduling for $args{day_name} (id $args{day_id}).\n";

	# Delta_DHMS will return positive values for all four return values if
	# the first date comes BEFORE the second date. It will return negative
	# values if the first date comes AFTER the second date.

	# Check that the end time is after the start time
	
	if ($args{start_time}{hh} >= $args{end_time}{hh}) {
		print "Start time must be after end time!\n";
		exit;
	};

	# Set up start and end times for weekdays and weekends

	my %hours = (
		weekday_start 	=> 	'08',
		weekday_end 	=>	'18',
		weekend_start	=>	'12',
		weekend_end	=>	'17',);

	# Check that start time and end time are within business hours for the given day of the week

	if ($args{day_id} >= 1 && $args{day_id} <= 5) {
		# Check against weekday start and end times
		my %result;
		@result{'dd','hh','mm','ss'} 
			= Date::Calc::Delta_DHMS(2011,5,23,@{$args{'start_time'}}{'hh','mm'},0,
			2011,5,23,$hours{'weekday_start'},0,0);
		print $result{'hh'} . "\n";
		if ($result{'hh'} > 0) {
			print "Specified start time is too early.\n";
			exit;
		};
		@result{'dd','hh','mm','ss'} 
			= Date::Calc::Delta_DHMS(2011,5,23,@{$args{'start_time'}}{'hh','mm'},0,
			2011,5,23,$hours{'weekday_end'},0,0);
		print $result{'hh'} . "\n";
		if ($result{'hh'} < 1 ) {
			print "Specified start time is too late.\n";
			exit;
		};
		@result{'dd','hh','mm','ss'} 
			= Date::Calc::Delta_DHMS(2011,5,23,@{$args{'end_time'}}{'hh','mm'},0,
			2011,5,23,$hours{'weekday_end'},0,0);
		print $result{'hh'} . "\n";
		if ($result{'hh'} < 0) {
			print "Specified end time is too late!\n";
			exit;
		};
		print "The given start and end times ($args{'start_time'}{'actual'} and $args{'end_time'}{'actual'}) are within acceptable ranges.\n";
	} elsif ($args{day_id} == 6) {
		# Check against weekend start and end times
		my %result;
		@result{'dd','hh','mm','ss'} 
			= Date::Calc::Delta_DHMS(2011,5,23,@{$args{'start_time'}}{'hh','mm'},0,
			2011,5,23,$hours{'weekend_start'},0,0);
		print $result{'hh'} . "\n";
		if ($result{'hh'} > 0) {
			print "Specified start time is too early.\n";
			exit;
		};
		@result{'dd','hh','mm','ss'} 
			= Date::Calc::Delta_DHMS(2011,5,23,@{$args{'start_time'}}{'hh','mm'},0,
			2011,5,23,$hours{'weekend_end'},0,0);
		print $result{'hh'} . "\n";
		if ($result{'hh'} < 1 ) {
			print "Specified start time is too late.\n";
			exit;
		};
		@result{'dd','hh','mm','ss'} 
			= Date::Calc::Delta_DHMS(2011,5,23,@{$args{'end_time'}}{'hh','mm'},0,
			2011,5,23,$hours{'weekend_end'},0,0);
		print $result{'hh'} . "\n";
		if ($result{'hh'} < 0) {
			print "Specified end time is too late!\n";
			exit;
		};
		print "The given start and end times ($args{'start_time'}{'actual'} and $args{'end_time'}{'actual'}) are within acceptable ranges.\n";
	} else {
		# If we got here something is off
		print "Specified time range outside of business hours!.\n";
		exit;
	};

	# Make sure a valid desk has been specified, check against output of get_desks()
	my $desks_hash_ref = get_desks();
	$args{desk_id} = get_id_from_value($args{desk_name},$desks_hash_ref);
	if ($args{desk_id} eq "no match") {
		print "No such desk \"$args{desk_name}\" exists in the database.\n";
	} else {
		print "$args{desk_name} has id $args{desk_id}.\n";
	};

	# If the first day of the term is after today, use it as the start date 
	# for the assignment operation. If it is after today use today's date 
	# as the first day.

	# Get the details of the term we're working with
	my $sth_get_term_dates = $dbh->prepare('
	SELECT ns_term_startdate, ns_term_enddate
	FROM ns_term
	WHERE ns_term_id = ?')
	or die "Couldn't prepare statement: " . $dbh->errstr;
	$sth_get_term_dates->bind_param(1,$args{term_id});
	$sth_get_term_dates->execute;

	# Populate the part of the term_startdate and term_enddate hashes
	# Fetch the "long forms" from the database
	($args{'term_startdate'}{'yyyy-mm-dd'},$args{'term_enddate'}{'yyyy-mm-dd'}) 
		= $sth_get_term_dates->fetchrow_array;
	
	# Chunk out the long forms for later usage
	@{$args{term_startdate}}{'yyyy','mm','dd'} 
		= ($args{term_startdate}{'yyyy-mm-dd'} 
		=~ m/(\d\d\d\d)-(\d\d)-(\d\d)/);
	@{$args{term_enddate}}{'yyyy','mm','dd'} 
		= ($args{term_enddate}{'yyyy-mm-dd'} 
		=~ m/(\d\d\d\d)-(\d\d)-(\d\d)/);

	# Delta_Days(yyyy,mm,dd,yyyy,mm,dd) returns positive if date 1 is 
	# BEFORE date 2, negative if date 1 is AFTER date 2. The return value
	# is the difference between the two dates measured in days.

	my %current_date = (
		'yyyy'	=> $args{'term_startdate'}{'yyyy'},
		'mm'	=> $args{'term_startdate'}{'mm'},
		'dd'	=> $args{'term_startdate'}{'dd'}, );
	# Enter loop to step through each day of the term
	while (Date::Calc::Delta_Days(@current_date{'yyyy','mm','dd'},@{$args{'term_enddate'}}{'yyyy','mm','dd'}) 
		>= 0) {
		$current_date{'yyyy-mm-dd'} = sprintf("%4d-%02d-%02d",@current_date{'yyyy','mm','dd'});
		# If a day matches the day to be assigned...
		if (Date::Calc::Day_of_Week(@current_date{'yyyy','mm','dd'}) == $args{'day_id'}) { 
			my $current_hour = $args{'start_time'}{'hh'};
			# Enter loop to step through the time range in one hour increments
			while ($current_hour < $args{'end_time'}{'hh'}) {
				# For each hour...
				# Try to grab a shift entry for the specified 
				# date and time, if one doesn't exist move on.
				my $shift_id 
					= get_shift_id(
					$current_date{'yyyy-mm-dd'},
					$current_hour,
					sprintf("%02d",$current_hour + 1));
				print "Got shift ID: $shift_id\n";
				if ($shift_id != 0) {
					# If a shift entry exists...
					# Check and see if an "active" 
					# assignment already exists for the 
					# specified CAT using check_shift()
					if (check_shift(
						$args{'dog_id'},
						$current_date{'yyyy-mm-dd'},
						$current_hour,
						sprintf("%02d",$current_hour + 1),
						$args{'desk_id'})) {
						# If one does, mention this and step to the next hour
						print "Active shift assignment already exists for $current_date{'yyyy-mm-dd'} starting at $current_hour, skipping.\n";
					} else {
						# If one doesn't, call new_assignment() 
						# and create a new shift assignment
						new_assignment(
							$args{'dog_id'},
							$current_date{'yyyy-mm-dd'},
							$current_hour,
							$args{'end_time'}{'hh'},
							$args{'desk_id'});
					};
				} else {
					print "No shift for " . $current_date{'yyyy-mm-dd'} . " at " . sprintf("%02d",$current_hour) . " exists.\n";
				};
				$current_hour = sprintf("%02d",$current_hour + 1);
			};
		} else {
			# If the day doesn't match the day to be assigned step to the next day
		};
		# ($year,$month,$day) = Add_Delta_Days($year,$month,$day, $Dd);
		@current_date{'yyyy','mm','dd'} 
			= Date::Calc::Add_Delta_Days(@current_date{'yyyy','mm','dd'},1);
	};

# If we got any other set of arguments just return a bad args message
} else { 
	print $invalid_args_message;
};

# Subroutines

# Gets the ID of the shift for a given date and time, if one exists.
# Args: date (yyyy-mm-dd), shift start (hh), shift end (hh)
sub get_shift_id {

	if (@_ != 3) { 
		print "get_shift_id() was passed an invalid number of arguments! (" . @_ . ").\n";
	};
	my %gsi_args;
	@gsi_args{'date','start','end'} = @_;
	$gsi_args{'start'} = sprintf("%02d:00:00",$gsi_args{'start'});
	$gsi_args{'end'} = sprintf("%02d:00:00",$gsi_args{'end'});
	
	my $sth_gsi = $dbh->prepare('
		SELECT ns_shift_id
		FROM ns_shift
		WHERE ns_shift_date = ?
		AND ns_shift_start_time = ?
		AND ns_shift_end_time = ?
		')
		or die "Couldn't prepare statement: " . $dbh->errstr;
	$sth_gsi->bind_param(1,$gsi_args{'date'});
	$sth_gsi->bind_param(2,$gsi_args{'start'});
	$sth_gsi->bind_param(3,$gsi_args{'end'});
	$sth_gsi->execute;

	my @shift_ids;
	while (my @gsi_result = $sth_gsi->fetchrow_array()) {
		if (@gsi_result == 1) {
			push(@shift_ids,$gsi_result[0]);
		} elsif (@gsi_result > 1) {
			print "Got too many columns from database query in get_shift_id()\n";
		};
	};

	if (@shift_ids > 1) {
		print "Found more than one shift for $gsi_args{'date'} at $gsi_args{'start'}: \n";
		for (my $i, @shift_ids) {
			print "$i\n";
		};
		exit; 
	} elsif (@shift_ids == 0) {
		print "No shifts found for $gsi_args{'date'} at $gsi_args{'start'}. \n";
		return 0;
	};

	return $shift_ids[0];
};

# Create new assignment entry
# Args: 'dog_id', date, start time, end time, 'desk_id'
sub new_assignment {
	if (@_ != 5) {
		print "new_assignment() was passed an invalid number of arguments! (" . @_ . ").\n";
		exit;
	};
	my %na_args; 
	@na_args{'dog_id','date','start_time','end_time','desk_id'} = @_;
	
};

# Determine if an "active" shift assignment exists for a CAT at a given date and time
# "Active" shift assignments are those for which the is not a corresponding entry in ns_shift_dropped
# Args: 'dog_id', date, start time, end time, 'desk_id'
sub check_shift { 

	if (@_ != 5) {
		print "check_shift() was passed an invalid number of arguments! (" . @_ . ").\n";
		exit;
	};
	my %cs_args; 
	@cs_args{'dog_id','date','start_time','end_time','desk_id'} = @_;
	$cs_args{'start'} = sprintf("%02d:00:00",$cs_args{'start_time'});
	$cs_args{'end'} = sprintf("%02d:00:00",$cs_args{'end_time'});

	
};

# Iterates through each entry of a hash to see if the given scalar exists as a
# value for any hash key and returns the key corresponding to that value if it
# exists. This will return the first key found, so if there may be multiple
# instances of the value being looked for this is not the subroutine to use.
# Args: Value to look for (scalar), hash reference to iterate through
sub get_id_from_value {
	my $search_value = $_[0];
	my $hash_ref = $_[1];
	my $return_id;
	foreach my $id (keys(%{$hash_ref})) {
		# Case insensitive! 
		if ($hash_ref->{$id} =~ m/$search_value/i) {
			$return_id = $id;
			last;
		};		
	};
	if (defined $return_id) {
		return $return_id;
	} else {
		return "no match";
	};
};

# Get all possible stations a DOG could be posted at, keyed to their id in ns_desk
# Args: None
#
# Output hash format:
# desk_id => desk_name
#
sub get_desks {
	my $sth_get_desks = $dbh->prepare(' 
	SELECT ns_desk_id, ns_desk_shortname
	FROM ns_desk')
	or die "Couldn't prepare statement: " . $dbh->errstr;
	$sth_get_desks->execute;
	my %return_hash;
	while (my @ns_desk_entry = $sth_get_desks->fetchrow_array()) {
		$return_hash{$ns_desk_entry[0]} = $ns_desk_entry[1];
	};
	return \%return_hash;
};

# Generate a hash of all current DOGs, keyed to their id in ns_cat
# Args: Types of CATzen to return (@dog_types) (optional)
#
# Output hash format:
# cat_id => cat_uname
#
sub get_dogs {
	# This sub might be called with a reference to an array containing the DOG 
	# types to fetch, if it is we need to handle that
	if (defined $_[0]) {
		my $types_ref = $_[0];
		# Since we're using this in a SQL query it needs to be formatted
		my $types_db_list;
		for (my $i = 0; $i < @$types_ref; $i++) {
			if ($i == 0) {
				$types_db_list = $types_ref->[$i];
			} else {
				$types_db_list .= "," . $types_ref->[$i];
			};
		};
		my $get_dogs_query = "SELECT ns_cat_id, ns_cat_uname FROM ns_cat WHERE ns_cat_type_id IN ($types_db_list)";
		my $sth_get_dogs = $dbh->prepare($get_dogs_query)
		or die "Couldn't prepare statement: " . $dbh->errstr;
		$sth_get_dogs->execute;
		my %return_hash;
		while (my @ns_cat_entry = $sth_get_dogs->fetchrow_array()) {
			$return_hash{$ns_cat_entry[0]} = $ns_cat_entry[1];
		};
		return \%return_hash;
	# If we don't get a list of CAT types to grab just get everyone
	} else {
		my $sth_get_dogs = $dbh->prepare('
		SELECT ns_cat_id, ns_cat_uname 
		FROM ns_cat')
		or die "Couldn't prepare statement: " . $dbh->errstr;
		$sth_get_dogs->execute;
		my %return_hash;
		while (my @ns_cat_entry = $sth_get_dogs->fetchrow_array()) {
			$return_hash{$ns_cat_entry[0]} = $ns_cat_entry[1];
		};
		return \%return_hash;
	}; 
};

# Get a hash of term names keyed to their id 
# Args: None
#
# Output hash format:
# term_id => term_name
#
sub get_terms {
	my $sth_get_terms = $dbh->prepare(' 
	SELECT ns_term_id, ns_term_name
	FROM ns_term')
	or die "Couldn't prepare statement: " . $dbh->errstr;
	$sth_get_terms->execute;
	my %return_hash;
	while (my @ns_term_entry = $sth_get_terms->fetchrow_array()) {
		$return_hash{$ns_term_entry[0]} = $ns_term_entry[1];
	};
	return \%return_hash;
};


